# ------------------------------
# .github/workflows/deploy-infra.yaml
# ------------------------------

# .github/workflows/deploy-infra.yaml
name: Deploy KubeShip Infrastructure on AWS EKS

on:
  push:
    branches:
      - main
    paths:
      - terraform/**
      - .github/workflows/deploy-infra.yaml

jobs:
  terraform:
    name: Terraform Deploy
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform

    env:
      AWS_REGION:                              ${{ secrets.AWS_REGION }}
      TF_PROJECT_NAME:                         ${{ secrets.TF_PROJECT_NAME }}
      TF_ENVIRONMENT:                          ${{ secrets.TF_ENVIRONMENT }}
      TF_EKS_CLUSTER_NAME:                     ${{ secrets.TF_EKS_CLUSTER_NAME }}
      TF_EKS_CLUSTER_VERSION:                  ${{ secrets.TF_EKS_CLUSTER_VERSION }}
      TF_GITOPS_REPO_URL:                      ${{ secrets.TF_GITOPS_REPO_URL }}
      TF_TARGET_REVISION:                      ${{ secrets.TF_TARGET_REVISION }}
      TF_ARGOCD_APP_MANIFEST_PATH:             ${{ secrets.TF_ARGOCD_APP_MANIFEST_PATH }}
      TF_AVAILABILITY_ZONE_1:                  ${{ secrets.TF_AVAILABILITY_ZONE_1 }}
      TF_AVAILABILITY_ZONE_2:                  ${{ secrets.TF_AVAILABILITY_ZONE_2 }}
      TF_STATE_BUCKET:                         ${{ secrets.TF_STATE_BUCKET }}
      TF_LOCK_TABLE:                           ${{ secrets.TF_LOCK_TABLE }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # ─── Buildx & QEMU setup for proper layer caching ─────────────────────────────
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver: docker-container
          use: true

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=infra/terraform.tfstate" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=${TF_LOCK_TABLE}"

      - name: Terraform Format
        run: terraform fmt -recursive

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform validate

      - name: Validate Required Secrets
        run: |
          echo "🔍 Checking required secrets..."
          REQUIRED=(
            TF_PROJECT_NAME TF_ENVIRONMENT TF_EKS_CLUSTER_NAME
            TF_EKS_CLUSTER_VERSION TF_GITOPS_REPO_URL
            TF_TARGET_REVISION TF_ARGOCD_APP_MANIFEST_PATH
            TF_AVAILABILITY_ZONE_1 TF_AVAILABILITY_ZONE_2
            TF_STATE_BUCKET TF_LOCK_TABLE
          )
          for key in "${REQUIRED[@]}"; do
            if [ -z "${!key}" ]; then
              echo "❌ Missing secret: $key"
              exit 1
            else
              echo "✅ $key is set"
            fi
          done

      - name: Generate secrets.auto.tfvars.json
        run: |
          cat > secrets.auto.tfvars.json <<EOF
          {
            "secrets_map": {
              "JWT_SECRET_KEY": "${{ secrets.JWT_SECRET_KEY }}",
              "JWT_ALGORITHM": "${{ secrets.JWT_ALGORITHM }}",
              "DATABASE_URL": "${{ secrets.DATABASE_URL }}",
              "REDIS_URL": "${{ secrets.REDIS_URL }}"
            }
          }
          EOF

      - name: 🔍 Validate secrets.auto.tfvars.json has no empty values
        run: |
          MISSING=$(jq -r '
            .secrets_map
            | to_entries[]
            | select(.value == "" or .value == null)
            | .key
          ' secrets.auto.tfvars.json)
          if [[ -n "$MISSING" ]]; then
            echo "❌ Found empty secrets: $MISSING"
            exit 1
          else
            echo "✅ All secrets have values"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repositories exist
        run: |
          for service in auth-service frontend nginx-gateway; do
            REPO="${TF_PROJECT_NAME}-${service}"
            if ! aws ecr describe-repositories --repository-names "$REPO" > /dev/null 2>&1; then
              aws ecr create-repository --repository-name "$REPO"
            fi
          done

      - name: Build & Push auth-service image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: microservices/auth-service/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.TF_PROJECT_NAME }}-auth-service:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.TF_PROJECT_NAME }}-auth-service:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & Push frontend image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: microservices/frontend/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.TF_PROJECT_NAME }}-frontend:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.TF_PROJECT_NAME }}-frontend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production

      - name: Build & Push nginx-gateway image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: nginx/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.TF_PROJECT_NAME }}-nginx-gateway:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.TF_PROJECT_NAME }}-nginx-gateway:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Terraform Plan
        run: |
          terraform plan -input=false -out=tfplan.out \
            -var-file="secrets.auto.tfvars.json" \
            -var="project_name=${TF_PROJECT_NAME}" \
            -var="environment=${TF_ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="eks_cluster_name=${TF_EKS_CLUSTER_NAME}" \
            -var="eks_cluster_version=${TF_EKS_CLUSTER_VERSION}" \
            -var="gitops_repo_url=${TF_GITOPS_REPO_URL}" \
            -var="target_revision=${TF_TARGET_REVISION}" \
            -var="argocd_app_manifest_path=${TF_ARGOCD_APP_MANIFEST_PATH}" \
            -var="availability_zones=[\"${TF_AVAILABILITY_ZONE_1}\", \"${TF_AVAILABILITY_ZONE_2}\"]"

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan.out

      - name: Save Terraform Outputs
        run: terraform output -json > tf-outputs.json
