# ------------------------------
# .github/workflows/deploy-infra.yaml
# ------------------------------
name: Deploy KubeShip Infrastructure on AWS EKS

on:
  push:
    branches:
      - main
    paths:
      - terraform/**
      - .github/workflows/deploy-infra.yaml

concurrency:
  group: deploy-infra-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write    
  contents: read  

env:
  IMAGE_TAG:       latest
  ECR_REPO_1:      auth-service
  ECR_REPO_2:      frontend
  ECR_REPO_3:      nginx-gateway
  REGION:          ${{ secrets.AWS_REGION }}
  ACCOUNT_ID:      ${{ secrets.AWS_ACCOUNT_ID }}
  TF_PROJECT_NAME: ${{ secrets.TF_PROJECT_NAME }}   
  TF_STATE_BUCKET:              ${{ secrets.TF_STATE_BUCKET }}
  TF_LOCK_TABLE:                ${{ secrets.TF_LOCK_TABLE }}
  TF_ENVIRONMENT:               ${{ secrets.TF_ENVIRONMENT }}
  TF_EKS_CLUSTER_NAME:          ${{ secrets.TF_EKS_CLUSTER_NAME }}
  TF_GITOPS_REPO_URL:           ${{ secrets.TF_GITOPS_REPO_URL }}
  TF_TARGET_REVISION:           ${{ secrets.TF_TARGET_REVISION }}
  TF_ARGOCD_APP_MANIFEST_PATH:  ${{ secrets.TF_ARGOCD_APP_MANIFEST_PATH }}
  TF_AVAILABILITY_ZONE_1:       ${{ secrets.TF_AVAILABILITY_ZONE_1 }}
  TF_AVAILABILITY_ZONE_2:       ${{ secrets.TF_AVAILABILITY_ZONE_2 }}
  TF_VAR_terraform_caller_arn:  ${{ secrets.CI_IAM_ROLE_ARN }}

jobs:
  build-and-push:
    name: Build & Push Docker images to ECR
    runs-on: ubuntu-latest
    outputs:
      auth-digest:     ${{ steps.auth-digest.outputs.digest }}
      frontend-digest: ${{ steps.frontend-digest.outputs.digest }}
      nginx-digest:    ${{ steps.nginx-digest.outputs.digest }}

    steps:
      - uses: actions/checkout@v3

      - name: Detect changed services
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            auth-service:
              - 'microservices/auth-service/**'
            frontend:
              - 'microservices/frontend/**'
            nginx-gateway:
              - 'nginx/**'
            shared:
              - 'shared/**'

      - name: Configure AWS credentials for ECR
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region:            ${{ env.REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Ensure ECR repos exist
        run: |
          for svc in auth-service frontend nginx-gateway; do
            aws ecr describe-repositories \
              --repository-names "${TF_PROJECT_NAME}-$svc" \
              --region "${REGION}" >/dev/null 2>&1 || \
            aws ecr create-repository \
              --repository-name "${TF_PROJECT_NAME}-$svc" \
              --region "${REGION}"
          done

      - uses: aws-actions/amazon-ecr-login@v2
      - uses: docker/setup-qemu-action@v2
      - uses: docker/setup-buildx-action@v2
        with:
          driver: docker-container
          use: true

      # -------- auth-service --------
      - name: Build auth-service image
        if: ${{ steps.changes.outputs['auth-service'] == 'true' || steps.changes.outputs.shared == 'true' }}
        run: |
          docker build -t $ECR_REPO_1:$IMAGE_TAG -f ./microservices/auth-service/Dockerfile ./microservices/auth-service

      - name: Tag, Push auth-service image to ECR
        id: auth-digest
        if: ${{ steps.changes.outputs['auth-service'] == 'true' || steps.changes.outputs.shared == 'true' }}
        run: |
          IMAGE_URI=${{ env.ACCOUNT_ID }}.dkr.ecr.${{ env.REGION }}.amazonaws.com/${{ env.TF_PROJECT_NAME }}-$ECR_REPO_1
          docker tag $ECR_REPO_1:$IMAGE_TAG $IMAGE_URI:$IMAGE_TAG
          docker push $IMAGE_URI:$IMAGE_TAG
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMAGE_URI:$IMAGE_TAG)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      # -------- frontend --------
      - name: Build frontend image
        if: ${{ steps.changes.outputs.frontend == 'true' || steps.changes.outputs.shared == 'true' }}
        run: |
          docker build -t $ECR_REPO_2:$IMAGE_TAG -f ./microservices/frontend/Dockerfile .

      - name: Tag, Push frontend image to ECR
        id: frontend-digest
        if: ${{ steps.changes.outputs.frontend == 'true' || steps.changes.outputs.shared == 'true' }}
        run: |
          IMAGE_URI=${{ env.ACCOUNT_ID }}.dkr.ecr.${{ env.REGION }}.amazonaws.com/${{ env.TF_PROJECT_NAME }}-$ECR_REPO_2
          docker tag $ECR_REPO_2:$IMAGE_TAG $IMAGE_URI:$IMAGE_TAG
          docker push $IMAGE_URI:$IMAGE_TAG
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMAGE_URI:$IMAGE_TAG)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      # -------- nginx-gateway --------
      - name: Build nginx-gateway image
        if: ${{ steps.changes.outputs['nginx-gateway'] == 'true' || steps.changes.outputs.shared == 'true' }}
        run: |
          docker build -t $ECR_REPO_3:$IMAGE_TAG -f ./nginx/Dockerfile ./nginx


      - name: Tag, Push nginx-gateway image to ECR
        id: nginx-digest
        if: ${{ steps.changes.outputs['nginx-gateway'] == 'true' || steps.changes.outputs.shared == 'true' }}
        run: |
          IMAGE_URI=${{ env.ACCOUNT_ID }}.dkr.ecr.${{ env.REGION }}.amazonaws.com/${{ env.TF_PROJECT_NAME }}-$ECR_REPO_3
          docker tag $ECR_REPO_3:$IMAGE_TAG $IMAGE_URI:$IMAGE_TAG
          docker push $IMAGE_URI:$IMAGE_TAG
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' $IMAGE_URI:$IMAGE_TAG)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

  deploy:
    name: Provision & Bootstrap EKS
    runs-on: ubuntu-latest
    needs: build-and-push
    defaults:
      run:
        working-directory: terraform

    steps:
      - uses: actions/checkout@v3

      - name: Authenticate to AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume:    ${{ secrets.CI_IAM_ROLE_ARN }}
          aws-region:        ${{ env.REGION }}
          role-session-name: github-actions-eks

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Terraform Init
        run: |
          terraform init -upgrade \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=infra/terraform.tfstate" \
            -backend-config="region=${REGION}" \
            -backend-config="dynamodb_table=${TF_LOCK_TABLE}"

      - name: Terraform Plan (cluster only)
        run: |
          terraform plan -target=module.eks -out=tfplan-cluster \
            -var="project_name=${TF_PROJECT_NAME}" \
            -var="environment=${TF_ENVIRONMENT}" \
            -var="eks_cluster_name=${TF_EKS_CLUSTER_NAME}" \
            -var="gitops_repo_url=${TF_GITOPS_REPO_URL}" \
            -var="target_revision=${TF_TARGET_REVISION}" \
            -var="argocd_app_manifest_path=${TF_ARGOCD_APP_MANIFEST_PATH}" \
            -var="availability_zones=[\"${TF_AVAILABILITY_ZONE_1}\",\"${TF_AVAILABILITY_ZONE_2}\"]" \
            -var="auth_image_digest=${{ needs.build-and-push.outputs.auth-digest }}" \
            -var="frontend_image_digest=${{ needs.build-and-push.outputs.frontend-digest }}" \
            -var="nginx_image_digest=${{ needs.build-and-push.outputs.nginx-digest }}" \
            -var="terraform_caller_arn=${{ secrets.CI_IAM_ROLE_ARN }}"


      - name: Terraform Apply (cluster only)
        run: terraform apply -auto-approve tfplan-cluster

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name "${{ env.TF_EKS_CLUSTER_NAME }}" \
            --region "${{ env.REGION }}"

      - name: Install ArgoCD CRDs
        run: |
          kubectl apply -k "https://github.com/argoproj/argo-cd/manifests/crds?ref=v2.9.3"

      - name: Terraform Plan & Apply (full sync)
        run: |
          terraform plan -out=tfplan2 \
            -var="project_name=${TF_PROJECT_NAME}" \
            -var="environment=${TF_ENVIRONMENT}" \
            -var="eks_cluster_name=${TF_EKS_CLUSTER_NAME}" \
            -var="gitops_repo_url=${TF_GITOPS_REPO_URL}" \
            -var="target_revision=${TF_TARGET_REVISION}" \
            -var="argocd_app_manifest_path=${TF_ARGOCD_APP_MANIFEST_PATH}" \
            -var="availability_zones=[\"${TF_AVAILABILITY_ZONE_1}\",\"${TF_AVAILABILITY_ZONE_2}\"]" \
            -var="auth_image_digest=${{ needs.build-and-push.outputs.auth-digest }}" \
            -var="frontend_image_digest=${{ needs.build-and-push.outputs.frontend-digest }}" \
            -var="nginx_image_digest=${{ needs.build-and-push.outputs.nginx-digest }}" \
            -var="terraform_caller_arn=${{ secrets.CI_IAM_ROLE_ARN }}"  
          terraform apply -auto-approve tfplan2